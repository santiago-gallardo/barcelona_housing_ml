import argparse
import json
from pathlib import Path

import pandas as pd
from joblib import load


def _load_features(features_path: Path) -> list[str]:
    """Load feature list from artifacts/features.json."""
    if not features_path.exists():
        raise FileNotFoundError(
            f"Features JSON not found: {features_path} (run train.py first to generate artifacts/features.json)"
        )

    meta = json.loads(features_path.read_text(encoding="utf-8"))
    feats = meta.get("features")

    if not isinstance(feats, list) or not feats or not all(isinstance(x, str) for x in feats):
        raise ValueError(
            f"Invalid features JSON at {features_path}. Expected key 'features' with a non-empty list of strings."
        )

    return feats


def _default_output_path(input_path: Path) -> Path:
    # e.g. data/raw/Barcelona_2018.csv -> reports/preds_Barcelona_2018.csv
    return Path("reports") / f"preds_{input_path.stem}.csv"


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Predict Barcelona Housing prices using trained model.")
    parser.add_argument("--model", default="artifacts/model.joblib",
                        help="Path to trained model (.joblib).")
    parser.add_argument(
        "--input",
        default="data/raw/Barcelona_2018.csv",
        help="Input CSV to predict. Default: data/raw/Barcelona_2018.csv",
    )
    parser.add_argument(
        "--output",
        default=None,
        help="Output CSV path. If omitted, defaults to reports/preds_<input_name>.csv",
    )
    parser.add_argument(
        "--features",
        default="artifacts/features.json",
        help="JSON with the feature list used at training time (generated by train.py).",
    )
    parser.add_argument(
        "--sep",
        default=";",
        help="CSV separator for input/output (default ';' for Barcelona_2018.csv).",
    )
    parser.add_argument(
        "--print-summary",
        action="store_true",
        help="Print a small summary (rows + pred min/mean/max) after saving output.",
    )
    args = parser.parse_args()

    model_path = Path(args.model)
    input_path = Path(args.input)
    features_path = Path(args.features)
    output_path = Path(
        args.output) if args.output else _default_output_path(input_path)

    if not model_path.exists():
        raise FileNotFoundError(f"Model not found: {model_path}")
    if not input_path.exists():
        raise FileNotFoundError(f"Input CSV not found: {input_path}")

    model = load(model_path)

    # Read with expected separator (your dataset uses ';')
    df = pd.read_csv(input_path, sep=args.sep)

    feats = _load_features(features_path)

    missing = [c for c in feats if c not in df.columns]
    if missing:
        hint = ""
        if len(df.columns) == 1:
            hint = (
                "\nHint: Your CSV seems to have been read as a single column. "
                "Check the separator. For Barcelona_2018.csv you likely need: --sep ';'"
            )
        raise ValueError(f"Missing required feature columns: {missing}{hint}")

    X = df[feats].copy()
    y_pred = model.predict(X)

    out = df.copy()
    out["PRED_PRICE"] = y_pred

    output_path.parent.mkdir(parents=True, exist_ok=True)
    out.to_csv(output_path, index=False, sep=args.sep)

    print(f"âœ… Saved predictions to: {output_path}")

    if args.print_summary:
        s = pd.Series(y_pred, name="PRED_PRICE")
        print(f"Rows predicted: {len(s)}")
        print(
            f"PRED_PRICE min/mean/max: {s.min():.3f} / {s.mean():.3f} / {s.max():.3f}")


if __name__ == "__main__":
    main()
